# 🎯 Malsami Expo 프로젝트 - 컴포넌트 분리 가이드

> **Cursor AI 사용 시**: `@컴포넌트_분리_가이드` 로 이 문서를 참조하세요!

---

## 📋 프로젝트 개요

### 🏗️ 프로젝트 정보

- **프로젝트명**: Malsami (React Native Expo 앱)
- **기술 스택**: React Native, Expo, TypeScript, React Query, Zustand
- **플랫폼**: iOS, Android 모바일 앱
- **주요 기능**: 학술 커뮤니티, 문서 공유, 질문 답변

### 📁 프로젝트 구조

```
/Expo/Malsami/
├── app/                    # Expo Router 기반 페이지
├── components/             # 재사용 가능한 UI 컴포넌트
├── hooks/                  # 커스텀 훅 (React Query 포함)
├── api/                    # API 통신 관련
├── types/                  # TypeScript 타입 정의
├── constants/              # 상수 정의
├── utils/                  # 유틸리티 함수
├── store/                  # 상태 관리 (Zustand)
└── assets/                 # 이미지, 폰트 등 정적 자원
```

---

## 🚨 핵심 컴포넌트 분리 규칙 (매우 중요!)

### 📏 코드 길이 기준

- **60줄 이상** → **즉시 분리 필수**
- **40-59줄** → 분리 고려 대상
- **재사용 가능성** → 줄 수 관계없이 분리

### 🔄 분리 프로세스

1. **큰 컴포넌트 식별**: 60줄 이상인 컴포넌트 찾기
2. **책임 분석**: 단일 책임 원칙에 따라 기능별 분리
3. **재사용성 검토**: 다른 곳에서 사용 가능한지 확인
4. **파일 생성**: 적절한 폴더에 새 컴포넌트 파일 생성
5. **Import/Export 정리**: 깔끔한 의존성 관계 유지

---

## 📂 컴포넌트 분리 패턴

### 🎯 분리 기준별 가이드

#### 1. **UI 요소별 분리**

```typescript
// ❌ 하나의 큰 컴포넌트 (80줄+)
function UserProfileScreen() {
  // 헤더 렌더링 (20줄)
  // 프로필 정보 렌더링 (25줄)
  // 설정 메뉴 렌더링 (20줄)
  // 하단 버튼들 렌더링 (15줄)
}

// ✅ 기능별로 분리
function UserProfileScreen() {
  return (
    <View>
      <UserProfileHeader />
      <UserProfileInfo />
      <UserSettingsMenu />
      <UserActionButtons />
    </View>
  );
}
```

#### 2. **로직별 분리**

```typescript
// ❌ 복잡한 로직이 섞인 컴포넌트
function DocumentListScreen() {
  // API 호출 로직 (15줄)
  // 필터링 로직 (20줄)
  // 정렬 로직 (15줄)
  // 렌더링 로직 (25줄)
}

// ✅ 커스텀 훅으로 로직 분리
function DocumentListScreen() {
  const { documents, isLoading } = useDocuments();
  const { filters, setFilter } = useDocumentFilters();
  const { sortedDocuments } = useDocumentSort(documents, filters);

  return <DocumentList documents={sortedDocuments} />;
}
```

#### 3. **상태별 분리**

```typescript
// ❌ 여러 상태가 섞인 컴포넌트
function QuestionForm() {
  // 폼 상태 관리 (20줄)
  // 유효성 검사 (15줄)
  // 파일 업로드 상태 (20줄)
  // 렌더링 (30줄)
}

// ✅ 상태별로 분리
function QuestionForm() {
  return (
    <View>
      <QuestionFormFields />
      <QuestionFormValidation />
      <QuestionFileUpload />
      <QuestionFormActions />
    </View>
  );
}
```

---

## 📁 폴더 구조별 분리 가이드

### 🏠 components/ 폴더 구조

```
components/
├── common/                 # 공통 컴포넌트 (재사용성 높음)
│   ├── Button.tsx
│   ├── InputField.tsx
│   ├── LoadingSpinner.tsx
│   └── Modal.tsx
├── auth/                   # 인증 관련 컴포넌트
│   ├── LoginForm.tsx
│   ├── SignupForm.tsx
│   └── AuthHeader.tsx
├── document/               # 문서 관련 컴포넌트
│   ├── DocumentCard.tsx
│   ├── DocumentList.tsx
│   └── DocumentForm.tsx
├── question/               # 질문 관련 컴포넌트
│   ├── QuestionCard.tsx
│   ├── QuestionList.tsx
│   └── QuestionForm.tsx
└── profile/                # 프로필 관련 컴포넌트
    ├── UserProfile.tsx
    ├── ProfileSettings.tsx
    └── ProfileStats.tsx
```

### 🎯 분리 우선순위

1. **common/** - 3곳 이상에서 사용되는 컴포넌트
2. **feature/** - 특정 기능에 특화된 컴포넌트
3. **screen/** - 화면별 전용 컴포넌트 (최후 수단)

---

## 🔧 실제 분리 예시

### 📝 Before: 큰 컴포넌트 (85줄)

```typescript
// DocumentDetailScreen.tsx (85줄)
function DocumentDetailScreen({ documentId }: Props) {
  // 상태 관리 (15줄)
  const [document, setDocument] = useState<Document | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [comments, setComments] = useState<Comment[]>([]);
  const [newComment, setNewComment] = useState("");

  // API 호출 (20줄)
  useEffect(() => {
    const fetchDocument = async () => {
      try {
        setIsLoading(true);
        const docData = await getDocument(documentId);
        const commentsData = await getDocumentComments(documentId);
        setDocument(docData);
        setComments(commentsData);
      } catch (error) {
        console.error("Error:", error);
      } finally {
        setIsLoading(false);
      }
    };
    fetchDocument();
  }, [documentId]);

  // 이벤트 핸들러 (15줄)
  const handleLike = async () => {
    try {
      await likeDocument(documentId);
      setDocument((prev) => (prev ? { ...prev, likes: prev.likes + 1 } : null));
    } catch (error) {
      console.error("Like error:", error);
    }
  };

  const handleCommentSubmit = async () => {
    try {
      const comment = await submitComment(documentId, newComment);
      setComments((prev) => [...prev, comment]);
      setNewComment("");
    } catch (error) {
      console.error("Comment error:", error);
    }
  };

  // 렌더링 (35줄)
  if (isLoading) return <LoadingSpinner />;
  if (!document) return <Text>문서를 찾을 수 없습니다.</Text>;

  return (
    <ScrollView>
      <View style={styles.header}>
        <Text style={styles.title}>{document.title}</Text>
        <Text style={styles.author}>{document.author}</Text>
        <Text style={styles.date}>{document.createdAt}</Text>
      </View>

      <View style={styles.content}>
        <Text>{document.content}</Text>
      </View>

      <View style={styles.actions}>
        <TouchableOpacity onPress={handleLike}>
          <Text>좋아요 ({document.likes})</Text>
        </TouchableOpacity>
      </View>

      <View style={styles.comments}>
        <Text style={styles.commentsTitle}>댓글 ({comments.length})</Text>
        {comments.map((comment) => (
          <View key={comment.id} style={styles.comment}>
            <Text style={styles.commentAuthor}>{comment.author}</Text>
            <Text>{comment.content}</Text>
          </View>
        ))}
      </View>

      <View style={styles.commentForm}>
        <TextInput
          value={newComment}
          onChangeText={setNewComment}
          placeholder="댓글을 입력하세요"
        />
        <TouchableOpacity onPress={handleCommentSubmit}>
          <Text>댓글 작성</Text>
        </TouchableOpacity>
      </View>
    </ScrollView>
  );
}
```

### ✅ After: 분리된 컴포넌트들

#### 1. **메인 스크린 컴포넌트** (25줄)

```typescript
// DocumentDetailScreen.tsx (25줄)
function DocumentDetailScreen({ documentId }: Props) {
  const { document, isLoading, error } = useDocument(documentId);

  if (isLoading) return <LoadingSpinner />;
  if (error) return <ErrorMessage error={error} />;
  if (!document) return <Text>문서를 찾을 수 없습니다.</Text>;

  return (
    <ScrollView>
      <DocumentHeader document={document} />
      <DocumentContent content={document.content} />
      <DocumentActions document={document} />
      <DocumentComments documentId={documentId} />
    </ScrollView>
  );
}
```

#### 2. **커스텀 훅으로 로직 분리** (30줄)

```typescript
// hooks/useDocument.ts (30줄)
function useDocument(documentId: string) {
  const [document, setDocument] = useState<Document | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchDocument = async () => {
      try {
        setIsLoading(true);
        setError(null);
        const docData = await getDocument(documentId);
        setDocument(docData);
      } catch (err) {
        setError(err instanceof Error ? err.message : "알 수 없는 오류");
      } finally {
        setIsLoading(false);
      }
    };

    fetchDocument();
  }, [documentId]);

  const updateDocument = (updates: Partial<Document>) => {
    setDocument((prev) => (prev ? { ...prev, ...updates } : null));
  };

  return { document, isLoading, error, updateDocument };
}
```

#### 3. **UI 컴포넌트들** (각각 15-20줄)

```typescript
// components/document/DocumentHeader.tsx (15줄)
function DocumentHeader({ document }: { document: Document }) {
  return (
    <View style={styles.header}>
      <Text style={styles.title}>{document.title}</Text>
      <Text style={styles.author}>{document.author}</Text>
      <Text style={styles.date}>{document.createdAt}</Text>
    </View>
  );
}

// components/document/DocumentContent.tsx (10줄)
function DocumentContent({ content }: { content: string }) {
  return (
    <View style={styles.content}>
      <Text>{content}</Text>
    </View>
  );
}

// components/document/DocumentActions.tsx (20줄)
function DocumentActions({ document }: { document: Document }) {
  const { likeDocument } = useDocumentActions();

  const handleLike = () => {
    likeDocument(document.id);
  };

  return (
    <View style={styles.actions}>
      <TouchableOpacity onPress={handleLike}>
        <Text>좋아요 ({document.likes})</Text>
      </TouchableOpacity>
    </View>
  );
}
```

---

## 🎯 분리 체크리스트

### ✅ 분리 전 확인사항

- [ ] 컴포넌트가 60줄 이상인가?
- [ ] 여러 책임을 가지고 있는가?
- [ ] 재사용 가능한 부분이 있는가?
- [ ] 로직과 UI가 섞여 있는가?
- [ ] 테스트하기 어려운 구조인가?

### ✅ 분리 후 확인사항

- [ ] 각 컴포넌트가 단일 책임을 가지는가?
- [ ] 컴포넌트 간 의존성이 명확한가?
- [ ] 재사용성이 향상되었는가?
- [ ] 테스트하기 쉬워졌는가?
- [ ] 코드 가독성이 개선되었는가?

---

## 🚀 자동화 도구 제안

### 🔍 컴포넌트 분석 스크립트

```bash
# 60줄 이상 컴포넌트 찾기
find ./components -name "*.tsx" -exec wc -l {} + | awk '$1 > 60 {print $2, $1 "줄"}'

# 복잡한 컴포넌트 우선순위 정렬
find ./components -name "*.tsx" -exec wc -l {} + | sort -nr | head -10
```

### 📊 분리 진행 상황 추적

- **목표**: 모든 컴포넌트 60줄 이하 유지
- **현재 상태**: 주기적으로 체크 필요
- **우선순위**: 가장 긴 컴포넌트부터 순차적 분리

---

## 💡 모범 사례

### ✅ 좋은 분리 예시

```typescript
// 명확한 책임 분리
<UserProfile>
  <UserAvatar /> {/* 아바타만 담당 */}
  <UserInfo /> {/* 기본 정보만 담당 */}
  <UserStats /> {/* 통계만 담당 */}
  <UserActions /> {/* 액션 버튼만 담당 */}
</UserProfile>
```

### ❌ 피해야 할 패턴

```typescript
// 모든 것을 한 컴포넌트에 몰아넣기
<UserProfileEverything>
  {/* 아바타 + 정보 + 통계 + 액션 + 설정 + ... */}
</UserProfileEverything>
```

---

## 🎯 실행 계획

### 📅 단계별 분리 계획

1. **1주차**: 80줄 이상 컴포넌트 식별 및 분리
2. **2주차**: 60-79줄 컴포넌트 분리
3. **3주차**: 재사용 가능한 컴포넌트 common으로 이동
4. **4주차**: 테스트 코드 작성 및 리팩토링 완료

### 🏆 성공 지표

- 모든 컴포넌트 60줄 이하 달성
- 컴포넌트 재사용성 30% 향상
- 코드 리뷰 시간 50% 단축
- 버그 발생률 20% 감소

---

> **💡 Tip**: 이 가이드를 따라 컴포넌트를 분리하면 코드의 가독성, 재사용성, 테스트 용이성이 크게 향상됩니다!
